{"version":3,"sources":["ng://ngx-guided-tour/lib/guided-tour.constants.ts","ng://ngx-guided-tour/lib/guided-tour.service.ts","ng://ngx-guided-tour/lib/guided-tour.component.ts","ng://ngx-guided-tour/lib/guided-tour.module.ts"],"names":["Orientation","Bottom","BottomLeft","BottomRight","Center","Left","Right","Top","TopLeft","TopRight","GuidedTourService","errorHandler","_this","this","_guidedTourCurrentStepSubject","Subject","_guidedTourOrbShowingSubject","_currentTourStepIndex","_currentTour","_onFirstStep","_onLastStep","_onResizeMessage","guidedTourCurrentStepStream","asObservable","guidedTourOrbShowingStream","fromEvent","window","pipe","debounceTime","subscribe","minimumScreenSize","innerWidth","next","title","content","getPreparedTourStep","prototype","nextStep","steps","closeAction","_setFirstAndLast","action","setTimeout","_checkSelectorValidity","completeCallback","resetTour","backStep","skipTour","skipCallback","document","body","classList","remove","startTour","tour","cloneDeep","filter","step","skipStep","useOrb","length","add","activateOrb","selector","querySelector","handleError","Error","tourId","Object","defineProperty","preventBackdropFromAdvancing","index","setTourOrientation","convertedStep","orientation","sort","a","b","maximumSize","currentOrientation_1","forEach","orientationConfig","orientationDirection","Injectable","ErrorHandler","GuidedTourComponent","guidedTourService","topOfPageAdjustment","tourStepWidth","minimalTourStepWidth","highlightPadding","currentTourStep","selectedElementRect","isOrbShowing","_announcementsCount","tourStep","adjustment","calculatedLeftPosition","Math","min","maxWidthAdjustmentForTourStep","widthAdjustmentForScreenBound","ngAfterViewInit","scrollToAndSetElement","value","resizeSubscription","updateStepLocation","scrollSubscription","ngOnDestroy","unsubscribe","isTourOnScreen","isBottom","topPos","scrollY","top","scrollAdjustment","getStepScreenAdjustment","scrollTo","left","behavior","err","TypeError","scroll","height","innerHeight","handleOrb","elementInViewport","nativeElement","element","offsetTop","offsetHeight","offsetParent","pageYOffset","backdropClick","event","stopPropagation","selectedElement","getBoundingClientRect","paddingAdjustment","getHighlightPadding","right","width","max","maxAdjustment","useHighlightPadding","elementHeight","Component","args","template","encapsulation","ViewEncapsulation","None","Input","ViewChild","GuidedTourModule","forRoot","ngModule","providers","NgModule","declarations","imports","CommonModule","exports","entryComponents"],"mappings":"0fAmDA,SAAAA,KAUA,OAT2BA,EAAAC,OAAS,SACTD,EAAAE,WAAa,cACbF,EAAAG,YAAc,eACdH,EAAAI,OAAS,SACTJ,EAAAK,KAAO,OACPL,EAAAM,MAAQ,QACRN,EAAAO,IAAM,MACNP,EAAAQ,QAAU,WACVR,EAAAS,SAAW,YACtCT,KC7DAU,EAAA,WAmBI,SAAAA,EACWC,GADX,IAAAC,EAAAC,KACWA,KAAAF,aAAAA,EATHE,KAAAC,8BAAgC,IAAIC,EAAAA,QACpCF,KAAAG,6BAA+B,IAAID,EAAAA,QACnCF,KAAAI,sBAAwB,EACxBJ,KAAAK,aAA2B,KAC3BL,KAAAM,cAAe,EACfN,KAAAO,aAAc,EACdP,KAAAQ,kBAAmB,EAKvBR,KAAKS,4BAA8BT,KAAKC,8BAA8BS,eACtEV,KAAKW,2BAA6BX,KAAKG,6BAA6BO,eAEpEE,EAAAA,UAAUC,OAAQ,UAAUC,KAAKC,EAAAA,aAAa,MAAMC,UAAS,WACrDjB,EAAKM,eAA8C,EAA9BN,EAAKK,wBACtBL,EAAKM,aAAaY,mBAAqBlB,EAAKM,aAAaY,mBAAqBJ,OAAOK,YACrFnB,EAAKS,kBAAmB,EACxBT,EAAKE,8BAA8BkB,KAAK,CACpCC,MAAO,gBACPC,QAAS,4JAGbtB,EAAKS,kBAAmB,EACxBT,EAAKE,8BAA8BkB,KAAKpB,EAAKuB,oBAAoBvB,EAAKK,4BA2L1F,OArLWP,EAAA0B,UAAAC,SAAP,WAAA,IAAAzB,EAAAC,KACQA,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBsB,aACpD1B,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBsB,cAEpD1B,KAAKK,aAAaoB,MAAMzB,KAAKI,sBAAwB,IACrDJ,KAAKI,wBACLJ,KAAK2B,mBACD3B,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBwB,QACpD5B,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBwB,SAEpDC,WAAU,WACF9B,EAAK+B,yBACL/B,EAAKE,8BAA8BkB,KAAKpB,EAAKuB,oBAAoBvB,EAAKK,wBAEtEL,EAAKyB,cAITxB,KAAK8B,yBACL9B,KAAKC,8BAA8BkB,KAAKnB,KAAKsB,oBAAoBtB,KAAKI,wBAEtEJ,KAAKwB,aAITxB,KAAKK,aAAa0B,kBAClB/B,KAAKK,aAAa0B,mBAEtB/B,KAAKgC,cAINnC,EAAA0B,UAAAU,SAAP,WAAA,IAAAlC,EAAAC,KACQA,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBsB,aACpD1B,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBsB,cAEpD1B,KAAKK,aAAaoB,MAAMzB,KAAKI,sBAAwB,IACrDJ,KAAKI,wBACLJ,KAAK2B,mBACD3B,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBwB,QACpD5B,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBwB,SACpDC,WAAU,WACF9B,EAAK+B,yBACL/B,EAAKE,8BAA8BkB,KAAKpB,EAAKuB,oBAAoBvB,EAAKK,wBAEtEL,EAAKkC,cAITjC,KAAK8B,yBACL9B,KAAKC,8BAA8BkB,KAAKnB,KAAKsB,oBAAoBtB,KAAKI,wBAEtEJ,KAAKiC,YAIbjC,KAAKgC,aAINnC,EAAA0B,UAAAW,SAAP,WACQlC,KAAKK,aAAa8B,cAClBnC,KAAKK,aAAa8B,aAAanC,KAAKI,uBAExCJ,KAAKgC,aAGFnC,EAAA0B,UAAAS,UAAP,WACII,SAASC,KAAKC,UAAUC,OAAO,aAC/BvC,KAAKK,aAAe,KACpBL,KAAKI,sBAAwB,EAC7BJ,KAAKC,8BAA8BkB,KAAK,OAGrCtB,EAAA0B,UAAAiB,UAAP,SAAiBC,GACbzC,KAAKK,aAAeqC,EAAAA,UAAUD,GAC9BzC,KAAKK,aAAaoB,MAAQzB,KAAKK,aAAaoB,MAAMkB,OAAM,SAACC,GAAQ,OAACA,EAAKC,WACvE7C,KAAKI,sBAAwB,EAC7BJ,KAAK2B,mBACL3B,KAAKG,6BAA6BgB,KAAKnB,KAAKK,aAAayC,QAEpB,EAAjC9C,KAAKK,aAAaoB,MAAMsB,UACnB/C,KAAKK,aAAaY,mBACfJ,OAAOK,YAAclB,KAAKK,aAAaY,qBAE1CjB,KAAKK,aAAayC,QACnBV,SAASC,KAAKC,UAAUU,IAAI,aAE5BhD,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBwB,QACpD5B,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuBwB,SAEpD5B,KAAK8B,yBACL9B,KAAKC,8BAA8BkB,KAAKnB,KAAKsB,oBAAoBtB,KAAKI,wBAEtEJ,KAAKwB,aAKV3B,EAAA0B,UAAA0B,YAAP,WACIjD,KAAKG,6BAA6BgB,MAAK,GACvCiB,SAASC,KAAKC,UAAUU,IAAI,cAGxBnD,EAAA0B,UAAAI,iBAAR,WACI3B,KAAKO,YAAeP,KAAKK,aAAaoB,MAAMsB,OAAS,IAAO/C,KAAKI,sBACjEJ,KAAKM,aAA8C,IAA/BN,KAAKI,uBAGrBP,EAAA0B,UAAAO,uBAAR,WACI,GAAI9B,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuB8C,WAC5Bd,SAASe,cAAcnD,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuB8C,UAM/F,OAJAlD,KAAKF,aAAasD,YAEd,IAAIC,MAAM,0BAA0BrD,KAAKK,aAAaoB,MAAMzB,KAAKI,uBAAuB8C,SAAQ,aAAYlD,KAAKI,sBAAwB,GAAC,wBAAwBJ,KAAKK,aAAaiD,UAEjL,EAGf,OAAO,GAGXC,OAAAC,eAAW3D,EAAA0B,UAAA,aAAU,KAArB,WACI,OAAOvB,KAAKO,6CAGhBgD,OAAAC,eAAW3D,EAAA0B,UAAA,cAAW,KAAtB,WACI,OAAOvB,KAAKM,8CAGhBiD,OAAAC,eAAW3D,EAAA0B,UAAA,kBAAe,KAA1B,WACI,OAAOvB,KAAKQ,kDAGhB+C,OAAAC,eAAW3D,EAAA0B,UAAA,yBAAsB,KAAjC,WACI,OAAOvB,KAAKI,sBAAwB,mCAGxCmD,OAAAC,eAAW3D,EAAA0B,UAAA,uBAAoB,KAA/B,WACI,OAAOvB,KAAKK,cAAgBL,KAAKK,aAAaoB,MAAQzB,KAAKK,aAAaoB,MAAMsB,OAAS,mCAG3FQ,OAAAC,eAAW3D,EAAA0B,UAAA,+BAA4B,KAAvC,WACI,OAAOvB,KAAKK,cAAgBL,KAAKK,aAAaoD,8DAG1C5D,EAAA0B,UAAAD,oBAAR,SAA4BoC,GACxB,OAAO1D,KAAK2D,mBAAmB3D,KAAKK,aAAaoB,MAAMiC,KAGnD7D,EAAA0B,UAAAoC,mBAAR,SAA2Bf,OACjBgB,EAAgBlB,EAAAA,UAAUE,GAChC,GACIgB,EAAcC,aAC4B,iBAA9BD,EAAcC,aACtBD,EAAyB,YAAgCb,OAC/D,CACGa,EAAyB,YAAgCE,KAAI,SAAEC,EAA6BC,GACzF,OAAKA,EAAEC,YAGFF,EAAEE,YAGAD,EAAEC,YAAcF,EAAEE,aAFb,EAHD,QAQXC,EAAkC/E,EAAYO,IACjDkE,EAAyB,YAAgCO,QAAO,SAC5DC,KACQA,EAAkBH,aAAepD,OAAOK,YAAckD,EAAkBH,eACzEC,EAAqBE,EAAkBC,wBAKnDT,EAAcC,YAAcK,EAEhC,OAAON,uBAtNdU,EAAAA,sDALQC,EAAAA,gBA6NT1E,EA9NA,GCAA2E,EAAA,WA6FI,SAAAA,EACWC,GAAAzE,KAAAyE,kBAAAA,EAdKzE,KAAA0E,oBAAuB,EACvB1E,KAAA2E,cAAiB,IACjB3E,KAAA4E,qBAAwB,IAEjC5E,KAAA6E,iBAAmB,EACnB7E,KAAA8E,gBAA4B,KAC5B9E,KAAA+E,oBAA+B,KAC/B/E,KAAAgF,cAAe,EAEdhF,KAAAiF,oBAAsB,EAsWlC,OA9VI1B,OAAAC,eAAYgB,EAAAjD,UAAA,gCAA6B,KAAzC,WACI,OAAOvB,KAAK2E,cAAgB3E,KAAK4E,sDAGrCrB,OAAAC,eAAYgB,EAAAjD,UAAA,gCAA6B,KAAzC,WACI,IAAKvB,KAAKkF,SACN,OAAO,MAEPC,EAAa,EAQjB,OAPInF,KAAKoF,uBAAyB,IAC9BD,GAAcnF,KAAKoF,wBAEnBpF,KAAKoF,uBAAyBvE,OAAOK,WAAalB,KAAK2E,gBACvDQ,EAAanF,KAAKoF,wBAA0BvE,OAAOK,WAAalB,KAAK2E,gBAGlEU,KAAKC,IAAItF,KAAKuF,8BAA+BJ,oCAGxD5B,OAAAC,eAAWgB,EAAAjD,UAAA,0BAAuB,KAAlC,WACI,OAAOvB,KAAK2E,cAAgB3E,KAAKwF,+DAG9BhB,EAAAjD,UAAAkE,gBAAP,WAAA,IAAA1F,EAAAC,KACIA,KAAKyE,kBAAkBhE,4BAA4BO,UAAS,SAAE4B,IAC1D7C,EAAK+E,gBAAkBlC,IACXA,EAAKM,SACWd,SAASe,cAAcP,EAAKM,UAEhDnD,EAAK2F,wBAEL3F,EAAKgF,oBAAsB,KAG/BhF,EAAKgF,oBAAsB,OAInC/E,KAAKyE,kBAAkB9D,2BAA2BK,UAAS,SAAE2E,GACzD5F,EAAKiF,aAAeW,IAGxB3F,KAAK4F,mBAAqBhF,EAAAA,UAAUC,OAAQ,UAAUG,UAAS,WAC3DjB,EAAK8F,uBAGT7F,KAAK8F,mBAAqBlF,EAAAA,UAAUC,OAAQ,UAAUG,UAAS,WAC3DjB,EAAK8F,wBAINrB,EAAAjD,UAAAwE,YAAP,WACI/F,KAAK4F,mBAAmBI,cACxBhG,KAAK8F,mBAAmBE,eAGrBxB,EAAAjD,UAAAmE,sBAAP,WAAA,IAAA3F,EAAAC,KACIA,KAAK6F,qBAELhE,WAAU,WACN,IAAK9B,EAAKiF,eAAiBjF,EAAKkG,iBAC5B,GAAIlG,EAAKgF,qBAAuBhF,EAAKmG,WAAY,KAEvCC,EAAWtF,OAAOuF,QAAUrG,EAAKgF,oBAAoBsB,IAAOtG,EAAK2E,qBAChE3E,EAAK+E,gBAAgBwB,iBAAmBvG,EAAK+E,gBAAgBwB,iBAAmB,GACjFvG,EAAKwG,0BACX,IACI1F,OAAO2F,SAAS,CACZC,KAAM,KACNJ,IAAKF,EACLO,SAAU,WAEhB,MAAOC,GACL,KAAIA,aAAeC,WAGf,MAAMD,EAFN9F,OAAOgG,OAAO,EAAGV,QAKtB,CAEGA,EAAUtF,OAAOuF,QAAUrG,EAAKgF,oBAAoBsB,IAAMtG,EAAKgF,oBAAoB+B,OACnFjG,OAAOkG,aACNhH,EAAK+E,gBAAgBwB,iBAAmBvG,EAAK+E,gBAAgBwB,iBAAmB,GACjFvG,EAAKwG,0BACX,IACI1F,OAAO2F,SAAS,CACZC,KAAM,KACNJ,IAAKF,EACLO,SAAU,WAEhB,MAAOC,GACL,KAAIA,aAAeC,WAGf,MAAMD,EAFN9F,OAAOgG,OAAO,EAAGV,QAUlC3B,EAAAjD,UAAAyF,UAAP,WACIhH,KAAKyE,kBAAkBxB,cACnBjD,KAAK8E,iBAAmB9E,KAAK8E,gBAAgB5B,UAC7ClD,KAAK0F,yBAILlB,EAAAjD,UAAA0E,eAAR,WACI,OAAOjG,KAAKkF,UACLlF,KAAKiH,kBAAkB7E,SAASe,cAAcnD,KAAK8E,gBAAgB5B,YACnElD,KAAKiH,kBAAkBjH,KAAKkF,SAASgC,gBAIxC1C,EAAAjD,UAAA0F,kBAAR,SAA0BE,GAItB,QAHId,EAAMc,EAAQC,UACZN,EAASK,EAAQE,aAEhBF,EAAQG,cAEXjB,IADAc,EAAWA,EAAoB,cAChBC,UAEnB,OAAIpH,KAAKkG,WAEDG,GAAQxF,OAAO0G,YACTvH,KAAK0E,qBACJ1E,KAAK8E,gBAAgBwB,iBAAmBtG,KAAK8E,gBAAgBwB,iBAAmB,GACjFtG,KAAKuG,2BACPF,EAAMS,GAAYjG,OAAO0G,YAAc1G,OAAOkG,YAIlDV,GAAQxF,OAAO0G,YAAcvH,KAAK0E,oBAAsB1E,KAAKuG,2BACzDF,EAAMS,GAAU9G,KAAK8E,gBAAgBwB,iBAAmBtG,KAAK8E,gBAAgBwB,iBAAmB,IAAQzF,OAAO0G,YAAc1G,OAAOkG,aAK7IvC,EAAAjD,UAAAiG,cAAP,SAAqBC,GACbzH,KAAKyE,kBAAkBhB,6BACvBgE,EAAMC,kBAEN1H,KAAKyE,kBAAkBjD,YAIxBgD,EAAAjD,UAAAsE,mBAAP,WACI,GAAI7F,KAAK8E,iBAAmB9E,KAAK8E,gBAAgB5B,SAAU,KACjDyE,EAAkBvF,SAASe,cAAcnD,KAAK8E,gBAAgB5B,UAEhElD,KAAK+E,oBADL4C,EAC4BA,EAAgBC,wBAEjB,UAG/B5H,KAAK+E,oBAAsB,MAI3BP,EAAAjD,UAAA2E,SAAR,WACI,OAAOlG,KAAK8E,gBAAgBjB,cACpB7D,KAAK8E,gBAAgBjB,cAAgB1E,EAAYC,QAClDY,KAAK8E,gBAAgBjB,cAAgB1E,EAAYE,YACjDW,KAAK8E,gBAAgBjB,cAAgB1E,EAAYG,cAG5DiE,OAAAC,eAAWgB,EAAAjD,UAAA,cAAW,KAAtB,eACUsG,EAAoB7H,KAAK8H,sBAE/B,OAAI9H,KAAKkG,WACElG,KAAK+E,oBAAoBsB,IAAMrG,KAAK+E,oBAAoB+B,OAASe,EAGrE7H,KAAK+E,oBAAoBsB,IAAMrG,KAAK8H,uDAG/CvE,OAAAC,eAAWgB,EAAAjD,UAAA,iBAAc,KAAzB,WACI,OAAIvB,KAAKkG,WACElG,KAAK+E,oBAAoBsB,IAAMrG,KAAK+E,oBAAoB+B,OAI/D9G,KAAK8E,gBAAgBjB,cAAgB1E,EAAYM,OAC9CO,KAAK8E,gBAAgBjB,cAAgB1E,EAAYK,KAE5CQ,KAAK+E,oBAAoBsB,IAAOrG,KAAK+E,oBAAoB+B,OAAS,EAGvE9G,KAAK+E,oBAAoBsB,qCAGpC9C,OAAAC,eAAYgB,EAAAjD,UAAA,yBAAsB,KAAlC,eACUsG,EAAoB7H,KAAK8H,sBAE/B,OACI9H,KAAK8E,gBAAgBjB,cAAgB1E,EAAYS,UAC9CI,KAAK8E,gBAAgBjB,cAAgB1E,EAAYG,YAE5CU,KAAK+E,oBAAoBgD,MAAQ/H,KAAK2E,cAI9C3E,KAAK8E,gBAAgBjB,cAAgB1E,EAAYQ,SAC9CK,KAAK8E,gBAAgBjB,cAAgB1E,EAAYE,WAE5CW,KAAK+E,oBAAwB,KAGrC/E,KAAK8E,gBAAgBjB,cAAgB1E,EAAYK,KAC1CQ,KAAK+E,oBAAoB0B,KAAOzG,KAAK2E,cAAgBkD,EAG5D7H,KAAK8E,gBAAgBjB,cAAgB1E,EAAYM,MACzCO,KAAK+E,oBAAoB0B,KAAOzG,KAAK+E,oBAAoBiD,MAAQH,EAGrE7H,KAAK+E,oBAAoBgD,MAAS/H,KAAK+E,oBAAoBiD,MAAQ,EAAMhI,KAAK2E,cAAgB,mCAG1GpB,OAAAC,eAAWgB,EAAAjD,UAAA,eAAY,KAAvB,WACI,GAAmC,GAA/BvB,KAAKoF,uBACL,OAAOpF,KAAKoF,2BAEVD,EAAaE,KAAK4C,IAAI,GAAIjI,KAAKoF,wBAC/B8C,EAAgB7C,KAAKC,IAAItF,KAAKuF,8BAA+BJ,GACnE,OAAOnF,KAAKoF,uBAAyB8C,mCAGzC3E,OAAAC,eAAWgB,EAAAjD,UAAA,kBAAe,KAA1B,WACI,OACIvB,KAAK8E,gBAAgBjB,cAAgB1E,EAAYS,UAC9CI,KAAK8E,gBAAgBjB,cAAgB1E,EAAYG,YAE7CU,KAAK+E,oBAAoBgD,MAIhC/H,KAAK8E,gBAAgBjB,cAAgB1E,EAAYQ,SAC9CK,KAAK8E,gBAAgBjB,cAAgB1E,EAAYE,WAE7CW,KAAK+E,oBAAoB0B,KAGhCzG,KAAK8E,gBAAgBjB,cAAgB1E,EAAYK,KAC1CQ,KAAK+E,oBAAoB0B,KAGhCzG,KAAK8E,gBAAgBjB,cAAgB1E,EAAYM,MACzCO,KAAK+E,oBAAoB0B,KAAOzG,KAAK+E,oBAAoBiD,MAG7DhI,KAAK+E,oBAAoBgD,MAAS/H,KAAK+E,oBAAoBiD,MAAQ,mCAG/EzE,OAAAC,eAAWgB,EAAAjD,UAAA,YAAS,KAApB,WACI,OACKvB,KAAK8E,gBAAgBjB,aACnB7D,KAAK8E,gBAAgBjB,cAAgB1E,EAAYO,KACjDM,KAAK8E,gBAAgBjB,cAAgB1E,EAAYS,UACjDI,KAAK8E,gBAAgBjB,cAAgB1E,EAAYQ,QAIjD,KAFI,qDAKf4D,OAAAC,eAAWgB,EAAAjD,UAAA,eAAY,KAAvB,WACI,OACKvB,KAAK8E,gBAAgBjB,aACnB7D,KAAK8E,gBAAgBjB,cAAgB1E,EAAYO,KACjDM,KAAK8E,gBAAgBjB,cAAgB1E,EAAYC,QACjDY,KAAK8E,gBAAgBjB,cAAgB1E,EAAYQ,SACjDK,KAAK8E,gBAAgBjB,cAAgB1E,EAAYE,WAMpDW,KAAK8E,gBAAgBjB,cAAgB1E,EAAYS,UAC9CI,KAAK8E,gBAAgBjB,cAAgB1E,EAAYG,YAE7C,yBAIPU,KAAK8E,gBAAgBjB,cAAgB1E,EAAYM,OAC9CO,KAAK8E,gBAAgBjB,cAAgB1E,EAAYK,KAE7C,wBAGJ,KAjBI,oDAoBf+D,OAAAC,eAAWgB,EAAAjD,UAAA,aAAU,KAArB,WACI,OAAIvB,KAAK+E,oBACE/E,KAAK+E,oBAAoBsB,IAAMrG,KAAK8H,sBAExC,mCAGXvE,OAAAC,eAAWgB,EAAAjD,UAAA,cAAW,KAAtB,WACI,OAAIvB,KAAK+E,oBACE/E,KAAK+E,oBAAoB0B,KAAOzG,KAAK8H,sBAEzC,mCAGXvE,OAAAC,eAAWgB,EAAAjD,UAAA,gBAAa,KAAxB,WACI,OAAIvB,KAAK+E,oBACE/E,KAAK+E,oBAAoB+B,OAAuC,EAA7B9G,KAAK8H,sBAE5C,mCAGXvE,OAAAC,eAAWgB,EAAAjD,UAAA,eAAY,KAAvB,WACI,OAAIvB,KAAK+E,oBACE/E,KAAK+E,oBAAoBiD,MAAsC,EAA7BhI,KAAK8H,sBAE3C,mCAGHtD,EAAAjD,UAAAuG,oBAAR,eACQD,EAAoB7H,KAAK8E,gBAAgBqD,oBAAsBnI,KAAK6E,iBAAmB,EAI3F,OAHI7E,KAAK8E,gBAAgBD,mBACrBgD,EAAoB7H,KAAK8E,gBAAgBD,kBAEtCgD,GAIHrD,EAAAjD,UAAAgF,wBAAR,WACI,GACIvG,KAAK8E,gBAAgBjB,cAAgB1E,EAAYK,MAC9CQ,KAAK8E,gBAAgBjB,cAAgB1E,EAAYM,MAEpD,OAAO,MAEL2I,EAAgBpI,KAAK+E,oBAAoB+B,QACxC9G,KAAK8E,gBAAgBwB,iBAAmBtG,KAAK8E,gBAAgBwB,iBAAmB,GACjFtG,KAAKkF,SAASgC,cAAcU,wBAAwBd,OAE1D,OAAKjG,OAAOkG,YAAc/G,KAAK0E,oBAAuB0D,EAC3CA,GAAiBvH,OAAOkG,YAAc/G,KAAK0E,qBAE/C,uBAxbd2D,EAAAA,UAASC,KAAA,CAAC,CACPpF,SAAU,kBACVqF,SAAU,wuHAsEVC,cAAeC,EAAAA,kBAAkBC,yvIA1E5B7I,kDA6EJ8I,EAAAA,6BACAA,EAAAA,oCACAA,EAAAA,wBACAC,EAAAA,UAASN,KAAA,CAAC,eA4Wf9D,EA/bA,GCAAqE,EAAA,WAMA,SAAAA,KAwBA,OATkBA,EAAAC,QAAd,WACI,MAAO,CACHC,SAAUF,EACVG,UAAW,CACPzE,EAAAA,aACA1E,yBApBfoJ,EAAAA,SAAQX,KAAA,CAAC,CACNY,aAAc,CACV1E,GAEJ2E,QAAS,CACLC,EAAAA,cAEJC,QAAS,CACL7E,GAEJ8E,gBAAiB,CACb9E,OAaRqE,EA9BA","sourcesContent":["\nexport interface TourStep {\n    /** Selector for element that will be highlighted */\n    selector?: string;\n    /** Tour title text */\n    title?: string;\n    /** Tour step text */\n    content: string;\n    /** Where the tour step will appear next to the selected element */\n    orientation?: Orientation | OrientationConfiguration[];\n    /** Action that happens when the step is opened */\n    action?: () => void;\n    /** Action that happens when the step is closed */\n    closeAction?: () => void;\n    /** Skips this step, this is so you do not have create multiple tour configurations based on user settings/configuration */\n    skipStep?: boolean;\n    /** Adds some padding for things like sticky headers when scrolling to an element */\n    scrollAdjustment?: number;\n    /** Adds default padding around tour highlighting. Does not need to be true for highlightPadding to work */\n    useHighlightPadding?: boolean;\n    /** Adds padding around tour highlighting in pixels, this overwrites the default for this step. Is not dependent on useHighlightPadding being true */\n    highlightPadding?: number;\n}\n\nexport interface GuidedTour {\n    /** Identifier for tour */\n    tourId: string;\n    /** Use orb to start tour */\n    useOrb?: boolean;\n    /** Steps fo the tour */\n    steps: TourStep[];\n    /** Function will be called when tour is skipped */\n    skipCallback?: (stepSkippedOn: number) => void;\n    /** Function will be called when tour is completed */\n    completeCallback?: () => void;\n    /** Minimum size of screen in pixels before the tour is run, if the tour is resized below this value the user will be told to resize */\n    minimumScreenSize?: number;\n    /**\n     * Prevents the tour from advancing by clicking the backdrop.\n     * This should only be set if you are completely sure your tour is displaying correctly on all screen sizes otherwise a user can get stuck.\n     */\n    preventBackdropFromAdvancing?: boolean;\n}\n\nexport interface OrientationConfiguration {\n    /** Where the tour step will appear next to the selected element */\n    orientationDirection: Orientation;\n    /** When this orientation configuration starts in pixels */\n    maximumSize?: number;\n}\n\nexport class Orientation {\n    public static readonly Bottom = 'bottom';\n    public static readonly BottomLeft = 'bottom-left';\n    public static readonly BottomRight = 'bottom-right';\n    public static readonly Center = 'center';\n    public static readonly Left = 'left';\n    public static readonly Right = 'right';\n    public static readonly Top = 'top';\n    public static readonly TopLeft = 'top-left';\n    public static readonly TopRight = 'top-right';\n}\n","import { debounceTime } from 'rxjs/internal/operators';\nimport { ErrorHandler, Injectable } from '@angular/core';\nimport { Observable, Subject, fromEvent } from 'rxjs';\nimport { GuidedTour, TourStep, Orientation, OrientationConfiguration } from './guided-tour.constants';\nimport { cloneDeep } from 'lodash';\n\n@Injectable()\nexport class GuidedTourService {\n    public guidedTourCurrentStepStream: Observable<TourStep>;\n    public guidedTourOrbShowingStream: Observable<boolean>;\n\n    private _guidedTourCurrentStepSubject = new Subject<TourStep>();\n    private _guidedTourOrbShowingSubject = new Subject<boolean>();\n    private _currentTourStepIndex = 0;\n    private _currentTour: GuidedTour = null;\n    private _onFirstStep = true;\n    private _onLastStep = true;\n    private _onResizeMessage = false;\n\n    constructor(\n        public errorHandler: ErrorHandler\n    ) {\n        this.guidedTourCurrentStepStream = this._guidedTourCurrentStepSubject.asObservable();\n        this.guidedTourOrbShowingStream = this._guidedTourOrbShowingSubject.asObservable();\n\n        fromEvent(window, 'resize').pipe(debounceTime(200)).subscribe(() => {\n            if (this._currentTour && this._currentTourStepIndex > -1) {\n                if (this._currentTour.minimumScreenSize && this._currentTour.minimumScreenSize >= window.innerWidth) {\n                    this._onResizeMessage = true;\n                    this._guidedTourCurrentStepSubject.next({\n                        title: 'Please resize',\n                        content: 'You have resized the tour to a size that is too small to continue. Please resize the browser to a larger size to continue the tour or close the tour.'\n                    });\n                } else {\n                    this._onResizeMessage = false;\n                    this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                }\n            }\n        });\n    }\n\n    public nextStep(): void {\n        if (this._currentTour.steps[this._currentTourStepIndex].closeAction) {\n            this._currentTour.steps[this._currentTourStepIndex].closeAction();\n        }\n        if (this._currentTour.steps[this._currentTourStepIndex + 1]) {\n            this._currentTourStepIndex++;\n            this._setFirstAndLast();\n            if (this._currentTour.steps[this._currentTourStepIndex].action) {\n                this._currentTour.steps[this._currentTourStepIndex].action();\n                // Usually an action is opening something so we need to give it time to render.\n                setTimeout(() => {\n                    if (this._checkSelectorValidity()) {\n                        this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                    } else {\n                        this.nextStep();\n                    }\n                });\n            } else {\n                if (this._checkSelectorValidity()) {\n                    this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                } else {\n                    this.nextStep();\n                }\n            }\n        } else {\n            if (this._currentTour.completeCallback) {\n                this._currentTour.completeCallback();\n            }\n            this.resetTour();\n        }\n    }\n\n    public backStep(): void {\n        if (this._currentTour.steps[this._currentTourStepIndex].closeAction) {\n            this._currentTour.steps[this._currentTourStepIndex].closeAction();\n        }\n        if (this._currentTour.steps[this._currentTourStepIndex - 1]) {\n            this._currentTourStepIndex--;\n            this._setFirstAndLast();\n            if (this._currentTour.steps[this._currentTourStepIndex].action) {\n                this._currentTour.steps[this._currentTourStepIndex].action();\n                setTimeout(() => {\n                    if (this._checkSelectorValidity()) {\n                        this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                    } else {\n                        this.backStep();\n                    }\n                });\n            } else {\n                if (this._checkSelectorValidity()) {\n                    this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n                } else {\n                    this.backStep();\n                }\n            }\n        } else {\n            this.resetTour();\n        }\n    }\n\n    public skipTour(): void {\n        if (this._currentTour.skipCallback) {\n            this._currentTour.skipCallback(this._currentTourStepIndex);\n        }\n        this.resetTour();\n    }\n\n    public resetTour(): void {\n        document.body.classList.remove('tour-open');\n        this._currentTour = null;\n        this._currentTourStepIndex = 0;\n        this._guidedTourCurrentStepSubject.next(null);\n    }\n\n    public startTour(tour: GuidedTour): void {\n        this._currentTour = cloneDeep(tour);\n        this._currentTour.steps = this._currentTour.steps.filter(step => !step.skipStep);\n        this._currentTourStepIndex = 0;\n        this._setFirstAndLast();\n        this._guidedTourOrbShowingSubject.next(this._currentTour.useOrb);\n        if (\n            this._currentTour.steps.length > 0\n            && (!this._currentTour.minimumScreenSize\n                || (window.innerWidth >= this._currentTour.minimumScreenSize))\n        ) {\n            if (!this._currentTour.useOrb) {\n                document.body.classList.add('tour-open');\n            }\n            if (this._currentTour.steps[this._currentTourStepIndex].action) {\n                this._currentTour.steps[this._currentTourStepIndex].action();\n            }\n            if (this._checkSelectorValidity()) {\n                this._guidedTourCurrentStepSubject.next(this.getPreparedTourStep(this._currentTourStepIndex));\n            } else {\n                this.nextStep();\n            }\n        }\n    }\n\n    public activateOrb(): void {\n        this._guidedTourOrbShowingSubject.next(false);\n        document.body.classList.add('tour-open');\n    }\n\n    private _setFirstAndLast(): void {\n        this._onLastStep = (this._currentTour.steps.length - 1) === this._currentTourStepIndex;\n        this._onFirstStep = this._currentTourStepIndex === 0;\n    }\n\n    private _checkSelectorValidity(): boolean {\n        if (this._currentTour.steps[this._currentTourStepIndex].selector) {\n            const selectedElement = document.querySelector(this._currentTour.steps[this._currentTourStepIndex].selector);\n            if (!selectedElement) {\n                this.errorHandler.handleError(\n                    // If error handler is configured this should not block the browser.\n                    new Error(`Error finding selector ${this._currentTour.steps[this._currentTourStepIndex].selector} on step ${this._currentTourStepIndex + 1} during guided tour: ${this._currentTour.tourId}`)\n                );\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public get onLastStep(): boolean {\n        return this._onLastStep;\n    }\n\n    public get onFirstStep(): boolean {\n        return this._onFirstStep;\n    }\n\n    public get onResizeMessage(): boolean {\n        return this._onResizeMessage;\n    }\n\n    public get currentTourStepDisplay(): number {\n        return this._currentTourStepIndex + 1;\n    }\n\n    public get currentTourStepCount(): number {\n        return this._currentTour && this._currentTour.steps ? this._currentTour.steps.length : 0;\n    }\n\n    public get preventBackdropFromAdvancing(): boolean {\n        return this._currentTour && this._currentTour.preventBackdropFromAdvancing;\n    }\n\n    private getPreparedTourStep(index: number): TourStep {\n        return this.setTourOrientation(this._currentTour.steps[index]);\n    }\n\n    private setTourOrientation(step: TourStep): TourStep {\n        const convertedStep = cloneDeep(step);\n        if (\n            convertedStep.orientation\n            && !(typeof convertedStep.orientation === 'string')\n            && (convertedStep.orientation as OrientationConfiguration[]).length\n        ) {\n            (convertedStep.orientation as OrientationConfiguration[]).sort((a: OrientationConfiguration, b: OrientationConfiguration) => {\n                if (!b.maximumSize) {\n                    return 1;\n                }\n                if (!a.maximumSize) {\n                    return -1;\n                }\n                return b.maximumSize - a.maximumSize;\n            });\n\n            let currentOrientation: Orientation = Orientation.Top;\n            (convertedStep.orientation as OrientationConfiguration[]).forEach(\n                (orientationConfig: OrientationConfiguration) => {\n                    if (!orientationConfig.maximumSize || window.innerWidth <= orientationConfig.maximumSize) {\n                        currentOrientation = orientationConfig.orientationDirection;\n                    }\n                }\n            );\n\n            convertedStep.orientation = currentOrientation;\n        }\n        return convertedStep;\n    }\n}\n","import { AfterViewInit, Component, ElementRef, Input, OnDestroy, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { fromEvent, Subscription } from 'rxjs';\nimport { Orientation, TourStep } from './guided-tour.constants';\nimport { GuidedTourService } from './guided-tour.service';\n\n@Component({\n    selector: 'ngx-guided-tour',\n    template: `\n        <div *ngIf=\"currentTourStep && selectedElementRect && isOrbShowing\"\n                (mouseenter)=\"handleOrb()\"\n                class=\"tour-orb tour-{{ currentTourStep.orientation }}\"\n                [style.top.px]=\"orbTopPosition\"\n                [style.left.px]=\"orbLeftPosition\"\n                [style.transform]=\"orbTransform\">\n                <div class=\"tour-orb-ring\"></div>\n        </div>\n        <div *ngIf=\"currentTourStep && !isOrbShowing\">\n            <div class=\"guided-tour-user-input-mask\" (click)=\"backdropClick($event)\"></div>\n            <div class=\"guided-tour-spotlight-overlay\"\n                [style.top.px]=\"overlayTop\"\n                [style.left.px]=\"overlayLeft\"\n                [style.height.px]=\"overlayHeight\"\n                [style.width.px]=\"overlayWidth\">\n            </div>\n        </div>\n        <div *ngIf=\"currentTourStep && !isOrbShowing\">\n            <div #tourStep *ngIf=\"currentTourStep\"\n                class=\"tour-step tour-{{ currentTourStep.orientation }}\"\n                [ngClass]=\"{\n                    'page-tour-step': !currentTourStep.selector\n                }\"\n                [style.top.px]=\"(currentTourStep.selector && selectedElementRect ? topPosition : null)\"\n                [style.left.px]=\"(currentTourStep.selector && selectedElementRect ? leftPosition : null)\"\n                [style.width.px]=\"(currentTourStep.selector && selectedElementRect ? calculatedTourStepWidth : null)\"\n                [style.transform]=\"(currentTourStep.selector && selectedElementRect ? transform : null)\">\n                <div *ngIf=\"currentTourStep.selector\" class=\"tour-arrow\"></div>\n                <div class=\"tour-block\">\n                    <h3 class=\"tour-title\" *ngIf=\"currentTourStep.title && currentTourStep.selector\">\n                        {{ currentTourStep.title }}\n                    </h3>\n                    <h2 class=\"tour-title\" *ngIf=\"currentTourStep.title && !currentTourStep.selector\">\n                        {{ currentTourStep.title }}\n                    </h2>\n                    <div class=\"tour-content\" [innerHTML]=\"currentTourStep.content\"></div>\n                    <div class=\"tour-buttons\">\n                        <button *ngIf=\"!guidedTourService.onResizeMessage\"\n                            (click)=\"guidedTourService.skipTour()\"\n                            class=\"skip-button link-button\">\n                            Skip\n                        </button>\n                        <button *ngIf=\"!guidedTourService.onLastStep && !guidedTourService.onResizeMessage\"\n                            class=\"next-button\"\n                            (click)=\"guidedTourService.nextStep()\">\n                            Next&nbsp;&nbsp;{{ guidedTourService.currentTourStepDisplay }}/{{ guidedTourService.currentTourStepCount }}\n                        </button>\n                        <button *ngIf=\"guidedTourService.onLastStep\"\n                            class=\"next-button\"\n                            (click)=\"guidedTourService.nextStep()\">\n                            Done\n                        </button>\n\n                        <button *ngIf=\"guidedTourService.onResizeMessage\"\n                            class=\"next-button\"\n                            (click)=\"guidedTourService.resetTour()\">\n                            Close\n                        </button>\n                        <button *ngIf=\"!guidedTourService.onFirstStep && !guidedTourService.onResizeMessage\"\n                            class=\"back-button link-button\"\n                            (click)=\"guidedTourService.backStep()\">\n                            Back\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    `,\n    styleUrls: ['./guided-tour.component.scss'],\n    encapsulation: ViewEncapsulation.None\n})\nexport class GuidedTourComponent implements AfterViewInit, OnDestroy {\n    @Input() public topOfPageAdjustment ?= 0;\n    @Input() public tourStepWidth ?= 300;\n    @Input() public minimalTourStepWidth ?= 200;\n    @ViewChild('tourStep') public tourStep: ElementRef;\n    public highlightPadding = 4;\n    public currentTourStep: TourStep = null;\n    public selectedElementRect: DOMRect = null;\n    public isOrbShowing = false;\n\n    private _announcementsCount = 0;\n    private resizeSubscription: Subscription;\n    private scrollSubscription: Subscription;\n\n    constructor(\n        public guidedTourService: GuidedTourService\n    ) { }\n\n    private get maxWidthAdjustmentForTourStep(): number {\n        return this.tourStepWidth - this.minimalTourStepWidth;\n    }\n\n    private get widthAdjustmentForScreenBound(): number {\n        if (!this.tourStep) {\n            return 0;\n        }\n        let adjustment = 0;\n        if (this.calculatedLeftPosition < 0) {\n            adjustment = -this.calculatedLeftPosition;\n        }\n        if (this.calculatedLeftPosition > window.innerWidth - this.tourStepWidth) {\n            adjustment = this.calculatedLeftPosition - (window.innerWidth - this.tourStepWidth);\n        }\n\n        return Math.min(this.maxWidthAdjustmentForTourStep, adjustment);\n    }\n\n    public get calculatedTourStepWidth() {\n        return this.tourStepWidth - this.widthAdjustmentForScreenBound;\n    }\n\n    public ngAfterViewInit(): void {\n        this.guidedTourService.guidedTourCurrentStepStream.subscribe((step: TourStep) => {\n            this.currentTourStep = step;\n            if (step && step.selector) {\n                const selectedElement = document.querySelector(step.selector);\n                if (selectedElement) {\n                    this.scrollToAndSetElement();\n                } else {\n                    this.selectedElementRect = null;\n                }\n            } else {\n                this.selectedElementRect = null;\n            }\n        });\n\n        this.guidedTourService.guidedTourOrbShowingStream.subscribe((value: boolean) => {\n            this.isOrbShowing = value;\n        });\n\n        this.resizeSubscription = fromEvent(window, 'resize').subscribe(() => {\n            this.updateStepLocation();\n        });\n\n        this.scrollSubscription = fromEvent(window, 'scroll').subscribe(() => {\n            this.updateStepLocation();\n        });\n    }\n\n    public ngOnDestroy(): void {\n        this.resizeSubscription.unsubscribe();\n        this.scrollSubscription.unsubscribe();\n    }\n\n    public scrollToAndSetElement(): void {\n        this.updateStepLocation();\n        // Allow things to render to scroll to the correct location\n        setTimeout(() => {\n            if (!this.isOrbShowing && !this.isTourOnScreen()) {\n                if (this.selectedElementRect && this.isBottom()) {\n                    // Scroll so the element is on the top of the screen.\n                    const topPos = ((window.scrollY + this.selectedElementRect.top) - this.topOfPageAdjustment)\n                        - (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)\n                        + this.getStepScreenAdjustment();\n                    try {\n                        window.scrollTo({\n                            left: null,\n                            top: topPos,\n                            behavior: 'smooth'\n                        });\n                    } catch (err) {\n                        if (err instanceof TypeError) {\n                            window.scroll(0, topPos);\n                        } else {\n                            throw err;\n                        }\n                    }\n                } else {\n                    // Scroll so the element is on the bottom of the screen.\n                    const topPos = (window.scrollY + this.selectedElementRect.top + this.selectedElementRect.height)\n                        - window.innerHeight\n                        + (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)\n                        - this.getStepScreenAdjustment();\n                    try {\n                        window.scrollTo({\n                            left: null,\n                            top: topPos,\n                            behavior: 'smooth'\n                        });\n                    } catch (err) {\n                        if (err instanceof TypeError) {\n                            window.scroll(0, topPos);\n                        } else {\n                            throw err;\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    public handleOrb(): void {\n        this.guidedTourService.activateOrb();\n        if (this.currentTourStep && this.currentTourStep.selector) {\n            this.scrollToAndSetElement();\n        }\n    }\n\n    private isTourOnScreen(): boolean {\n        return this.tourStep\n            && this.elementInViewport(document.querySelector(this.currentTourStep.selector))\n            && this.elementInViewport(this.tourStep.nativeElement);\n    }\n\n    // Modified from https://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport\n    private elementInViewport(element: HTMLElement): boolean {\n        let top = element.offsetTop;\n        const height = element.offsetHeight;\n\n        while (element.offsetParent) {\n            element = (element.offsetParent as HTMLElement);\n            top += element.offsetTop;\n        }\n        if (this.isBottom()) {\n            return (\n                top >= (window.pageYOffset\n                    + this.topOfPageAdjustment\n                    + (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)\n                    + this.getStepScreenAdjustment())\n                && (top + height) <= (window.pageYOffset + window.innerHeight)\n            );\n        } else {\n            return (\n                top >= (window.pageYOffset + this.topOfPageAdjustment - this.getStepScreenAdjustment())\n                && (top + height + (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)) <= (window.pageYOffset + window.innerHeight)\n            );\n        }\n    }\n\n    public backdropClick(event: Event): void {\n        if (this.guidedTourService.preventBackdropFromAdvancing) {\n            event.stopPropagation();\n        } else {\n            this.guidedTourService.nextStep();\n        }\n    }\n\n    public updateStepLocation(): void {\n        if (this.currentTourStep && this.currentTourStep.selector) {\n            const selectedElement = document.querySelector(this.currentTourStep.selector);\n            if (selectedElement) {\n                this.selectedElementRect = (selectedElement.getBoundingClientRect() as DOMRect);\n            } else {\n                this.selectedElementRect = null;\n            }\n        } else {\n            this.selectedElementRect = null;\n        }\n    }\n\n    private isBottom(): boolean {\n        return this.currentTourStep.orientation\n            && (this.currentTourStep.orientation === Orientation.Bottom\n            || this.currentTourStep.orientation === Orientation.BottomLeft\n            || this.currentTourStep.orientation === Orientation.BottomRight);\n    }\n\n    public get topPosition(): number {\n        const paddingAdjustment = this.getHighlightPadding();\n\n        if (this.isBottom()) {\n            return this.selectedElementRect.top + this.selectedElementRect.height + paddingAdjustment;\n        }\n\n        return this.selectedElementRect.top - this.getHighlightPadding();\n    }\n\n    public get orbTopPosition(): number {\n        if (this.isBottom()) {\n            return this.selectedElementRect.top + this.selectedElementRect.height;\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.Right\n            || this.currentTourStep.orientation === Orientation.Left\n        ) {\n            return (this.selectedElementRect.top + (this.selectedElementRect.height / 2));\n        }\n\n        return this.selectedElementRect.top;\n    }\n\n    private get calculatedLeftPosition(): number {\n        const paddingAdjustment = this.getHighlightPadding();\n\n        if (\n            this.currentTourStep.orientation === Orientation.TopRight\n            || this.currentTourStep.orientation === Orientation.BottomRight\n        ) {\n            return (this.selectedElementRect.right - this.tourStepWidth);\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.TopLeft\n            || this.currentTourStep.orientation === Orientation.BottomLeft\n        ) {\n            return (this.selectedElementRect.left);\n        }\n\n        if (this.currentTourStep.orientation === Orientation.Left) {\n            return this.selectedElementRect.left - this.tourStepWidth - paddingAdjustment;\n        }\n\n        if (this.currentTourStep.orientation === Orientation.Right) {\n            return (this.selectedElementRect.left + this.selectedElementRect.width + paddingAdjustment);\n        }\n\n        return (this.selectedElementRect.right - (this.selectedElementRect.width / 2) - (this.tourStepWidth / 2));\n    }\n\n    public get leftPosition(): number {\n        if (this.calculatedLeftPosition >= 0) {\n            return this.calculatedLeftPosition;\n        }\n        const adjustment = Math.max(0, -this.calculatedLeftPosition)\n        const maxAdjustment = Math.min(this.maxWidthAdjustmentForTourStep, adjustment);\n        return this.calculatedLeftPosition + maxAdjustment;\n    }\n\n    public get orbLeftPosition(): number {\n        if (\n            this.currentTourStep.orientation === Orientation.TopRight\n            || this.currentTourStep.orientation === Orientation.BottomRight\n        ) {\n            return this.selectedElementRect.right;\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.TopLeft\n            || this.currentTourStep.orientation === Orientation.BottomLeft\n        ) {\n            return this.selectedElementRect.left;\n        }\n\n        if (this.currentTourStep.orientation === Orientation.Left) {\n            return this.selectedElementRect.left;\n        }\n\n        if (this.currentTourStep.orientation === Orientation.Right) {\n            return (this.selectedElementRect.left + this.selectedElementRect.width);\n        }\n\n        return (this.selectedElementRect.right - (this.selectedElementRect.width / 2));\n    }\n\n    public get transform(): string {\n        if (\n            !this.currentTourStep.orientation\n            || this.currentTourStep.orientation === Orientation.Top\n            || this.currentTourStep.orientation === Orientation.TopRight\n            || this.currentTourStep.orientation === Orientation.TopLeft\n        ) {\n            return 'translateY(-100%)';\n        }\n        return null;\n    }\n\n    public get orbTransform(): string {\n        if (\n            !this.currentTourStep.orientation\n            || this.currentTourStep.orientation === Orientation.Top\n            || this.currentTourStep.orientation === Orientation.Bottom\n            || this.currentTourStep.orientation === Orientation.TopLeft\n            || this.currentTourStep.orientation === Orientation.BottomLeft\n        ) {\n            return 'translateY(-50%)';\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.TopRight\n            || this.currentTourStep.orientation === Orientation.BottomRight\n        ) {\n            return 'translate(-100%, -50%)';\n        }\n\n        if (\n            this.currentTourStep.orientation === Orientation.Right\n            || this.currentTourStep.orientation === Orientation.Left\n        ) {\n            return 'translate(-50%, -50%)';\n        }\n\n        return null;\n    }\n\n    public get overlayTop(): number {\n        if (this.selectedElementRect) {\n            return this.selectedElementRect.top - this.getHighlightPadding();\n        }\n        return 0;\n    }\n\n    public get overlayLeft(): number {\n        if (this.selectedElementRect) {\n            return this.selectedElementRect.left - this.getHighlightPadding();\n        }\n        return 0;\n    }\n\n    public get overlayHeight(): number {\n        if (this.selectedElementRect) {\n            return this.selectedElementRect.height + (this.getHighlightPadding() * 2);\n        }\n        return 0;\n    }\n\n    public get overlayWidth(): number {\n        if (this.selectedElementRect) {\n            return this.selectedElementRect.width + (this.getHighlightPadding() * 2);\n        }\n        return 0;\n    }\n\n    private getHighlightPadding(): number {\n        let paddingAdjustment = this.currentTourStep.useHighlightPadding ? this.highlightPadding : 0;\n        if (this.currentTourStep.highlightPadding) {\n            paddingAdjustment = this.currentTourStep.highlightPadding;\n        }\n        return paddingAdjustment;\n    }\n\n    // This calculates a value to add or subtract so the step should not be off screen.\n    private getStepScreenAdjustment(): number {\n        if (\n            this.currentTourStep.orientation === Orientation.Left\n            || this.currentTourStep.orientation === Orientation.Right\n        ) {\n            return 0;\n        }\n        const elementHeight = this.selectedElementRect.height\n            + (this.currentTourStep.scrollAdjustment ? this.currentTourStep.scrollAdjustment : 0)\n            + this.tourStep.nativeElement.getBoundingClientRect().height;\n\n        if ((window.innerHeight - this.topOfPageAdjustment) < elementHeight) {\n            return elementHeight - (window.innerHeight - this.topOfPageAdjustment);\n        }\n        return 0;\n    }\n}\n","import { GuidedTourService } from './guided-tour.service';\nimport { GuidedTourComponent } from './guided-tour.component';\nimport { NgModule, ErrorHandler } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ModuleWithProviders } from '@angular/compiler/src/core';\n\n@NgModule({\n    declarations: [\n        GuidedTourComponent\n    ],\n    imports: [\n        CommonModule\n    ],\n    exports: [\n        GuidedTourComponent\n    ],\n    entryComponents: [\n        GuidedTourComponent\n    ]\n})\nexport class GuidedTourModule {\n    public static forRoot(): ModuleWithProviders {\n        return {\n            ngModule: GuidedTourModule,\n            providers: [\n                ErrorHandler,\n                GuidedTourService\n            ]\n        };\n    }\n}\n"]}